    1.虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终
形成可以被虚拟机直接使用的Java类型。
    2.在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载的时候稍微增加
一些性能开销，但是会为Java应用程序提供高度的灵活性。如编写一个面向接口的应用程序，可以等到运行时再指定其实际的
实现类。

    3.类加载的时机
        a.类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载-->验证--->准备--->解析
    --->初始化--->使用--->卸载 7个阶段。其中验证、准备、解析三个部分统称为【连接】。
            -其中 【加载、验证、准备、初始化、卸载必须严格按照顺序执行】
        b.虚拟机严格规定有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在之前执行）
            i.遇到new、getstatic、putstatic、invokestatic 这四个字节码指令的时候，如果没有对类进行过
        初始化，则需要先触发其初始化。常见场景有：new关键字实例化对象的时候、读取或设置一个类的静态字段
        （被final修饰的、已在编译期放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
            ii.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，就需要先初始化。
            iii.初始化一个类的时候，如果其父类还没有初始化，则需要先触发其父类的初始化。
            iv.当虚拟机启动时，用户需要制定一个执行的主类（包含main方法的类），虚拟机会先初始化这个类。
            v.当使用JDK1.7的动态语言支持的时候，如果一个java.lang.invoke.MethodHandle实例最后的解析
        结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄对应的类没有进行
        初始化，则需要先触发其初始化。
        PS【接口也有初始化过程，一个接口初始化的时候，并不要求其父类接口全部完成初始化，只有在真正用到父类接口的
    时候（如应用接口中定义的常量）才会初始化】

    4.符号引用与直接引用的区别
        a.符号引用
            符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目
        即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经已经加载到内存中。各种虚拟机实现的
        内存布局可以各不相同，但是他们能接收的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java
        虚拟机规范的Class文件格式中。

        b.直接引用
            直接引用可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。直接引用是和虚拟机实
        现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接
        引用，那引用的目标必定已经在内存中存在。



