    1.线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何
其他的协调操作，调用这个对象都可以获得正确的结果，那么这个对象就是线程安全的。
    2.Java语言中各种操作共享的数据分为以下5类。
        a.不可变的共享数据：不可变的对象，一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。
        b.绝对线程安全的共享数据：不管运行时环境如何，调用者都不需要任何额外的同步措施。
        c.相对线程安全的共享数据：需要保证对这个对象单独的操作是线程安全的。
        d.线程兼容的共享数据：指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段，保证对象在并发环境下可以安全的使用。
        e.线程对立的共享数据：指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码。

    3.线程安全的实现方法
        *a.互斥同步（阻塞同步/悲观锁）
            i.互斥同步是一种常见的并发正确性保障手段。在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。
            ii.最常用的就是 synchronized 关键字。
            iii.synchronized同步块对同一个线程是可重入的（可重入是指同一个线程，外层获得锁后，内层仍有获得这个锁的代码，不受影响）；
            iv.synchronized 在Java语言中是一个重量及的操作，因为没有获得到锁的线程会从用户态转为内核态，这需要很多时间。
            v.在java.util.concurrent包中的重入锁（ReentrantLock）也可以实现同步。其中ReentrantLock具备一些高级功能：等待中断，
        可实现公平锁（先到先得），以及锁可以绑定多个条件。
                -等待中断：指持有锁的线程长期不释放锁的时候，等待中的线程可以放弃等待，做其他事情。
                -公平锁：指多个线程等待同一个锁的时候，必须安全申请锁的时间顺序来依次获得锁。
                -绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象。

        *b.非阻塞同步（乐观锁）
            i.基于【冲突检测】的乐观并发策略，先进行【操作】，如果没有其他线程争用共享数据，那操作就成功了，如果有数据争用，产生了冲突，那就采取
        其他补偿措施。
            ii.乐观并发策略是基于硬件指令集的发展，因为需要保证【操作】【冲突检测】具备原子性。
            iii.在Java API中，java.util.concurrent里面有这样的类。如AtomicInteger等(可自行查看java.util.concurrent.atomic下的类)。

        c.无同步方案

    4.锁优化
        a.自旋锁和自适应自旋（针对互斥同步的等待线程从用户态转为内核态费时的情况）
        b.锁消除：指虚拟机即时编译器在运行时，对一些代码上需要同步，但被检测到不可能存在共享数据竞争的锁进行消除。
        c.锁粗化。
        d.轻量级锁。
        e.偏向锁。
