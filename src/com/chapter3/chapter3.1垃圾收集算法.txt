    摘要：标记-清除算法、复制算法、标记整理、分代收集
    1.标记-清除算法(最基础的收集算法)
        a.该算法分为标记和清除两步:
            i.对需要回收的对象，进行统一标记（见chapter3.0.txt）。
            ii.标记完成后，统一回收对象。
        b.不足：
            i.效率问题：标记清除两个过程的效率不高；
            ii.空间问题：标记清除后会产生大量的不连续内存碎片。
                -空间碎片太多可能会导致以后程序运行过程中需要分配较大的对象时，无法找到足够的连续内存空间
            而不得不提前出发另一次垃圾回收动作。

    2.**复制算法
        a.为了解决效率问题。
        b.现有模式 Eden+Survivor1+Survivor2 比列：8:1:1
        c.是经过IBM的研究证明，新生代的对象98%是朝生夕死。
        d.如果Survivor2的内存不够存储 垃圾回收Eden和Survivor1后剩余的存活对象(大于10%)，将会把多余的对象，
    放到年老代（分配担保）。

    3.标记整理算法
        a.也是标记对象，然后将存活的对象往一段移动，最后再清除端边界之外的对象。

    4.**分代收集算法（综合使用前面三种算法）
        a.就是根据对象存活周期的不同将内存划分为几块。
        b.一般是把java堆分为新生代和年老代。这样就可以根据各个代的不同特点，采用不同的收集算法。
        c.新生代，存活率很底，选用复制算法 Eden:Survivor1:Survivor2=8:1:1
        d.年老代对象存活率高，没有额外的空间进行分配担保，必须使用“标记-清除”或“标记整理”算法。
