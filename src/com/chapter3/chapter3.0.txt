摘要：垃圾收集器与内存分配策略、可达性分析算法、对象的两次标记、方法区回收。

输出GC日志的VM args
-XX:+PrintGCDetails 输出GC详细日志；
-XX:+PrintGC 输出简单GC日志；
-XX:+PrintGCDateStamps 输出GC的时间戳；
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）；
-Xloggc:C:/Java/tmp/test_gc.log 日志文件输出路径；
PS：需要学习GC日志文件的解析。

    1.Java与C++的区别，内存动态分配和垃圾收集技术。
    2.垃圾收集（GC）需要完成的3件事情
        a.哪些内存需要收集？
        b.什么时候回收？
        c.如何回收？
    3.了解GC和内存分配的必要：
        a.需要排查各种内存溢出、内存泄漏问题；
        b.垃圾收集成为系统达到更高并发量的瓶颈时。
        以上两点都需要对GC和内存分配实施必要的监控和调节。
    4.内存的分配与回收针对java对和方法区的内存。

    5.垃圾收集器对堆进行回收前，第一步是判断对堆中对象是否 [不可能再被任何途径使用]。
        a.判断对象是否存活的方法
            i:引用计数算法（*JVM没有使用*）
                -释义：被一个地方引用，计数器加1,；引用失效时，计数器减1，任何时刻计数器为0时，对象不可能再被使用。
                -问题：存在对象之间相互循环引用的问题。

            ii.** 可达性分析算法（*JVM使用*）
                -释义：该算法的基本思想是通过一系列的成为【GC Roots】的对象作为起始点，这些节点向下搜索，
            搜索所走过的路径成为【引用链（Reference Chain）】，当一个对象到GC Roots没有任何引用链相连接时，
            则证明此对象不可用，会被判定为可回收对象。
                -java中可以被作为GC Roots的对象有以下几种:
                    *虚拟机栈（栈帧中的本地变量表）中引用的对象；
                    *方法区中类静态属性引用的对象；
                    *方法区中常量引用的对象；
                    *本地方法栈中JNI（一般所说的Native方法）引用的方法。

    6.对象的引用
        a.强引用：只程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还在，
    垃圾回收器永远不会回收掉被引用的对象。
        b.软引用：用来描述一些有用但是非必须的对象。对于弱引用关联着的对象，在系统【将要发生内存溢出异常前】，
    会把这些对象列入回收范围之内进行【二次回收】。
        c.弱引用：仍是描述有用非必需的对象，但比软引用弱。只能生存到下一次垃圾收集之前。
        d.虚引用：该引用的存在，与对象是否被回收完全无关，存在的目的是为了能在这个对象
    被垃圾收集器回收时收到一个系统通知

    7.对象被回收的两次标记
        a.第一次：如果对象在进行可达性分析后没有与GC Roots相连接的引用链，那么他们被第一标记并进行一次筛选，
    筛选条件-此对象是【否有必要】执行finalize()方法。如果该对象没有覆盖finalize()方法，或者finalize()方法已经被
    调用，者两种就视为“没必要执行”【结果就是被回收】
        b.第二次：如果对象被判定有必要执行finalize()方法。F-queue队列、Finalizer线程、finalize()方法中拯救自己。
    8.任何对象的finalize()方法只会被系统自动调用一次。如果对象面临下一次回收，他的finalize()方法不会再次执行。

    9.回收方法区
        a.方法区(永久代)的来垃圾收集效率很低。
        b.方法区(永久代)的垃圾收集主要内容：废弃常量和无用的类。

