关键词：[堆内存溢出、栈溢出、栈深度、运行时常量池、线程获更多、方法区与常量池溢出、VM args]
PS：VM args:-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=路径（不包含文件名）   可以让虚拟机出现内存异常时Dump出当前内存堆转储为快照存储，
以便分析。（C:\Java\idea-workspace\JvmDemo）

1.java虚拟机运行时数据区
    a.方法区、java堆（垃圾回收器管理的主要区域） ----- 线程共享
    b.虚拟机栈，本地方法栈，程序计数器 ----- 线程私有内存
2.运行时常量池是方法区的一部分，用于存放编译期生成的各种字面常量和符号引用。
3.对象的内存布局
    a.对象头（Header）：包含两部分信息
        i.存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁等。
        ii.类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
    b.实例数据部分：对象存储的有效信息，也是程序代码中定义的各种类型的字段内容。
    c.对齐填充：不是鼻炎存在的，没有特比含义，仅仅起占位符的作用。

4.Java堆溢出
    a.java堆用于存储对象的实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制
    清除这些对象。那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。
    java.lang.OutOfMemoryError: Java heap space
    b.VM args：-Xms20m(堆最小20M) -Xmx20m(堆最大20M)

5.栈溢出（虚拟机栈、本地方法栈）
    1.VM args: -Xss20m
    2.栈溢出的两种异常
        a.如果线程请求的【栈深度】大于虚拟机允许的最大深度，将抛出StackOverflowError异常。
            i.栈的深度，在使用虚拟机默认参数的时候，可以达到1000~2000是没有什么问题的。
        b.如果虚拟机扩展栈时，无法申请到足够的【内存空间】，则抛出OutOfMemoryError异常。
    3.如果建立因为建立线程太多导致内存溢出，可以通过【减少最大堆（-Xmx）和减小最栈容量（-Xss）】来换取更多的线程。
6.方法区和运行时常量池溢出
    1.运行时常量池是方法区的一部分。
    2.方法区大小设置：Vm args  -XX:PermSize=10m -XX:MaxPermSize=10m
    3.**方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。
    4.方法区溢出异常：java.lang.OutOfMemory:PermGen space
7.本机直接内存溢出
        1.VM args: -XX:MaxDirectMemorySize=100M
        2.直接内存溢出现象
            i.Head Dump文件中看不见明显异常
            ii.OOM之后Dump文件很小。

