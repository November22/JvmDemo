    一、概述
        计算机支持多任务处理的原因：计算机的运行速度与他的存储和通信子系统的速度差距太大，大量的时间
    都花费在磁盘的I/O、网络通信或者数据库访问上。
        衡量一个服务的高低好坏的重要指标之一就是 【每秒事务处理书（Transactions Per Second，TPS）】，
    它代表一秒内服务端平均能响应的请求总数。而TPS值与程序并发能力有关。

    二、Java内存模型
        Java虚拟机规范试图定义一种【内存模型】来屏蔽掉个各种硬件和操作系统的‘内存访问差异’，以实现让Java
    在各种平台下都能达到一致的内存访问效果。

        2.1 主内存与工作内存
            a.Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从
        内存中取出变量这样的底层细节。
            **PS：此处的变量是指线程共享的变量，如实例字段、静态字段等等，像局部变量与方法参数这样线程
        私有的，不会被共享。
            b.Java内存模型规定了所有变量都存在【主内存（Main Memory）】中。每条线程还有自己的【工作内存
        （Working Memory）】，*线程的工作内存保存了该线程使用到变量的主内存副本拷贝*，线程对变量的所有
        操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。不能线程不能直接访问对方
        的工作内存。

        2.2内存间交互操作
            关于主内存与工作内存之间的交互协议，Java内存模型定义了8种操作来完成，虚拟机保证了这8中操作都是
        原子的、不可再分的。
            a.lock（锁定）：作用于主内存变量，它把一个变量标识为一条线程独占的状态。
            b.unlock（解锁）：作用于主内存的变量，它把一个处于锁定的变量释放出来，释放后的变量才可以被其他
        线程锁定。
            c.read（读取）：作用于主内存的变量，他把一个变量的值从主内存【传输】到线程的工作内存中，以便随
        后的load动作使用。
            d.load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入到工作内存的变量副本中。
            e.use（使用）：作用于工作内存的变量，它把内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要
        使用到变量的值的字节码指令时将会执行这个操作。
            f.assign（赋值）：作用于工作内存的变量，他把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机
        遇到一个给变量赋值的字节码指令时执行这个操作。
            g.store（存储）：作用于工作内存的变量，他把工作内存中一个变量的值传送到主内存中，以便随后的write操作
        使用。
            h.write（写入）：作用于主内存的变量，他把store操作从工作内存中得到的变量的值放入主内存变量中。
            **PS：Java内存模型只要求read和load、store和write是顺序执行的，但是不保证是连续执行的。但必须是
        成对的。
            **assign操作后的变量，必须被同步回主内存。
            **新的变量只能在内存中诞生。
            **一个变量在同一时刻只允许一条线程对其进行lock操作。可以被该线程多次lock，但需要对应次数的unlock
        才能被解锁。
            **对一个变量执行lock后，那就会清空工作内存中此【变量的值{不是清除}】，在使用此值得时候，会重新
        执行load和assign操作初始化变量的值。

        2.3对于volatile型变量的特殊规则
            当一个变量定义为volatile后，具备两种特性
            1.保证此变量对所有线程可见性，这是值当一条线程修改了这个变量的值，新值对于其他变量来说是立即得知的。
            PS：因为变量被定义为volatile后，每次使用之前都会先刷新。但不能保证是线程安全的，它虽然在使用前会更新
        值，但是在使用的时候，说不定其他线程就更改了他的值。
            2.禁止指令重排序优化。
                -普通变量仅仅保证在该方法的执行过程中，所有依赖赋值结果的地方都能取得正确的结果，但不能保证赋值操
            作的顺序与代码的顺序是一致的。

        2.4原子性、可见性和有序性
            java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性3个特征来建立的。
            *原子性：java内存模型的8种操作都具有原子性，其中lock和unlock可以由synchronized关键字来操作。
            *可见性：指一个线程修改共享变量的值，其他线程能够立即得知这个修改。volatile的规则能保证新值，
        立即同步会主内存，以及每次使用从主内存刷新。其中synchronized和final也能实现这个功能。
            *有序性：主要针对指令重新排序优化

        2.4Java线程状态
            1.新建（New）：创建后尚未启动的线程处于这种状态。
            2.运行（Runable）：Runable包括了线程状态中的Runing和Ready，也就是处于此状态的线程有可能在执行，
        也有可能在等待着CPU为它分配执行时间。
            3.无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，他们需要等待被其他线程显示的
        唤醒。以下方法可以让线程进入Waiting状态：
                a.没有设置timeout参数的Object.wait()方法。
                b.没有设置timeout参数的Thread.join()方法。
                c.LockSupport.park()方法。
            4.限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无需等待其他线程的
        显示唤醒，在一定时间后，由系统自动唤醒。
                a.Thread.sleep()方法。
                b.设置了timeout参数的Thread.join()方法。
                c.设置了timeout参数的Object.wait()方法。
                d.LockSupport.parkNanons()方法。
                e.LockSupport.parkUntil()方法。
            5.阻塞（Blocked）：线程被阻塞了。阻塞状态与等待状态的区别是：阻塞状态在等待获取一个排它锁，这个事
        件发生在另外一个线程放弃这个所的时候发生。
            6.结束（Terminated）：线程执行结束。
